\section{Supersafety to Perfect Timeliness}\label{sec:backward-reduction}

We now construct a perfectly timely protocol $\Pi^*$
using a black-box reduction from a supersafe, and live($u$) protocol $\Pi$.
Each honest party $P$, executing the $\Pi^*$ protocol, runs a
full node of protocol $\Pi$.
The ledger of party $P$ for protocol $\Pi$ and $\Pi^*$ is denoted as $\Ledger[][P][r]$ and
$\Ledger[*][P][r]$ respectively.
To construct temporal ledger $\Ledger[*][][r]$,
new transactions appearing in
$\Ledger[][][r]$ are appended to $\Ledger[*][][r - 1]$ with recorded round $r$.
This process is illustrated
in Figure~\ref{fig:backward-reduction}
and the pseudocode is presented in Algorithm~\ref{alg:backward-reduction}.

\begin{figure}
  \centering
  \includegraphics[width=0.9\columnwidth,keepaspectratio]{figures/backward-reduction.pdf}
  \caption{The reduction from Supersafety
    (the $\Pi$ protocol) to Perfect Timeliness (the $\Pi^*$ protocol).
    New transactions of $\Ledger[][][r]$ are included in
    $\Ledger[*][][r]$ with recorded round $r$.
  }
 \label{fig:backward-reduction}
\end{figure}

\import{./}{algorithms/algorithm-backward-reduction.tex}

%We now prove that protocol $\Pi^*$ is perfectly timely.

\begin{theorem}[Supersafety to Perfect Timeliness] \label{thm:backward-reduction}
  An execution of protocol $\Pi^*$ is perfectly timely, supersafe, and live($u$), if the execution of
  protocol $\Pi$ is supersafe and live($u$).
\end{theorem}
\begin{proof}
  Timeliness requirements (1) and (2) are directly satisfied.
  For (3) consider any honest party $P$ and any rounds $r_1 \leq r_2$.
  Only transactions with recorded round greater
  than $r_1$ appear in ledger $\Ledger[*][P][r_2]{[|\Ledger[*][P][r_1]|{:}]}$.
  Hence, $\Pi^*$ is timely with parameter $v = 0$.
  Supersafety and liveness($u$) follow from those of $\Pi$.
  \Qed
\end{proof}

\atnote{We define clients in the beginning, but we only use them here.}
With a couple of addition to the above construction, we can add support for late joining clients.
From now on, we allow protocol $\Pi$ to be parameterized by a
transaction validity language.
Each of the $n$ honest parties runs another instance of protocol
$\Pi$, which we call $\Pi_2$.
In every round $r$, honest parties introduce a transaction
to their $\Pi_2$ instance which contains ledger $\Ledger[*][P][r]$.
We set the transaction validity language of $\Pi_2$ to be as follows:
Valid transactions contain any ledger $\hat \Ledger \preccurlyeq \Ledger[*][P][r]$.

Suppose a late joining client is activated by the environment.
The client first synchronizes the two instances of $\Pi$ with the
rest of the peers. Once synchronized, the client stores the transactions
appearing in ledger $\Ledger$ for each round.
For the next few rounds, the client observes the ledger of instance $\Pi_2$ for the
recorded rounds of the previous transactions.
The observed recorded rounds are accurate since they must satisfy $\Pi_2$'s
new transaction validity rule.
Eventually, all missing recorded rounds are
recovered, and the client can report the correct temporal ledger $\Ledger[*]$.

\begin{figure}
  \centering
  \includegraphics[width=0.65\columnwidth,keepaspectratio]{figures/clients.pdf}
  \caption{Client support for $\Pi$.
  }
 \label{fig:backward-reduction}
\end{figure}