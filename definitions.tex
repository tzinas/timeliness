\section{Preliminaries \& Model}

\textbf{Notation.}
%TODO: Complete
We use the set builder notation with [] for sequences.

In a distributed ledger protocol execution, the notation
$\Ledger[P][][r]$ denotes the output of $\rread()$
invoked on party $P$ at the end of round $r$. 
We denote that ledger
$\Ledger[P_1][][r_1]$ is a prefix of ledger $\Ledger[P_2][][r_2]$,
using the notation
$\Ledger[P_1][][r_1] \preccurlyeq \Ledger[P_2][][r_2]$. When
$(\Ledger[P_1][][r_1] \preccurlyeq \Ledger[P_2][][r_2]) \lor (\Ledger[P_2][][r_2] \preccurlyeq \Ledger[P_1][][r_1])$ holds,
we use the notation $\Ledger[P_1][][r_1] \sim \Ledger[P_2][][r_2]$.


\dznote{Define model: synchronous time, global clocks}

First, we note a few preliminary definitions.


\atnote{Define Synchrony, Partial Synchrony, GST, liveness under synchrony, safety}

% TODO: \kappa is the security parameter.

\begin{definition}[Stickiness]
  A distributed ledger protocol is \emph{sticky} if
  for any honest party $P$ and any rounds $r_1 \leq r_2$,
  it holds that $\Ledger[P][][r_1] \preceq \Ledger[P][][r_2]$.
\end{definition}

\begin{definition}[Safety]
  A distributed ledger protocol is \emph{safe} if
  for any honest parties $P_1, P_2$ and any rounds $r_1, r_2$, it holds that
  $\Ledger[P_1][][r_1]~\sim~\Ledger[P_2][][r_2]$. Additionally, the
  protocol is sticky.
\end{definition}

\atnote{Do we want to correlate stickiness with safety and supersafety?}

Stickiness can be easily enforced in any safe protocol
without stickiness by having the parties report the longest
ledger they have seen so far~\cite{streamlet}.


\begin{definition}[Liveness in Partial Synchrony]
  A distributed ledger protocol, in a partially synchronous network,
  is \emph{live}$(u)$ if all transactions written to any honest party
  at round $r$, appear in the ledgers of all honest parties by round %TODO (tzinas): by?
  $\max{(r,\gst)} + u$.
\end{definition}

\atnote{Make it more formal? Talk about execution maybe}

\section{Definitions}
The following definitions are first introduced in this work.

\begin{definition}[Temporal Ledger]
  A \emph{temporal ledger} is a finite sequence of pairs $(r, \tx)$ where $\tx$ is
  a transaction, and $r$ is a \emph{round} indicating the time at which
  the transaction in question is recorded on the ledger.
\end{definition}

\begin{definition}[Distributed Temporal Ledger Protocol]
  A \emph{distributed temporal ledger protocol} is a distributed ledger protocol
  that when \rread is invoked, honest parties output temporal ledgers instead of traditional ledgers.
\end{definition}

\begin{definition}[Timely]\label{def:timely}
  A distributed temporal ledger protocol is \emph{timely}$(v)$
  if for all honest parties $P$ and rounds $r_1$ it holds that:

  \begin{enumerate}
    \item The rounds recorded in $\Ledger[P][][r_1]$ are non-decreasing.\label{def:timely-increasing}
    \item The round recorded at $\Ledger[P][][r_1][-1]$ is at most $r_1$.\label{def:timely-past}
    \item For all $r_1 \leq r_2$, the rounds recorded in $\Ledger[P][][r_2][|\Ledger[P][][r_1]|{:}]$ are
          newer than $r_1 - v$.\label{def:timely-chunk}
  \end{enumerate}
\end{definition}

\atnote{Timeliness is orthogonal to safety and liveness. There are protocols that are safe, live but not timely. }

\begin{definition}[Supersafety]
  A distributed ledger protocol is \emph{supersafe} if
  for any honest parties $P_1, P_2$ and any round $r$, it holds that
  $\Ledger[P_1][][r] = \Ledger[P_2][][r]$.Additionally, the
  protocol is sticky.
\end{definition}

All supersafe protocols are safe.
